from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import *
from Application import Application
from CategoryPopUpWindow import Ui_createDialog
from EditCategoryPopUpWindow import Ui_editDialog
from APIData import TransactionData
from EmbeddedMatplotlibWindow import PlottingWindow
from EmbeddedMatplotlibWindow import ProjectionWidget
from pandas import to_datetime

class DragDropTableWidget(QtWidgets.QTableWidget):
  '''
  This class utilizes the concept of inheritance. It is
  the child class of QTableWidget, which means that it 
  has all of the functionality of QTableWidget, but has
  the ability to implement its own extra methods that
  QTableWidget does not have, and re-implement QTableWidget
  methods in its own specialized way. In our case,
  we are re-implementing the dropEvent() method so that
  it carries out our own specified functionality when called -
  I believe it does nothing by default.
  '''
  def __init__(self, app, mainWindow, parent = None):
    self.app = app
    self.mainWindow = mainWindow
    super(DragDropTableWidget, self).__init__(parent)

  def dropEvent(self, event):
    event.accept()
    row = self.mainWindow.tableWidget.currentRow()
    referenceNumber = int(self.mainWindow.tableWidget.item(row, 0).text())
    date = self.mainWindow.tableWidget.item(row, 1).text()
    location = self.mainWindow.tableWidget.item(row, 2).text()
    amount = self.mainWindow.tableWidget.item(row, 3).text()
    self.mainWindow.tableWidget.removeRow(row)
    c = self.app.getCategoryNamesList()[self.mainWindow.categoryWidget.currentIndex() + 1]
    self.app.registerCompletedTransaction(c, referenceNumber)
    self.app.saveData()
    self.mainWindow.updateAnalysisTable(c)
    self.mainWindow.moveRowToDropDestination(referenceNumber, date, location, amount, c)

##############################################################################################
                    # end of auto-generated code
##############################################################################################


    self.app = Application()

    # Import Tab
    self.app.initialize()
    self.importCSVBtn.clicked.connect(self.saveStartInfo)

    # Categorize Tab
    self.createCategoryWidget()
    self.openCatPopUp.clicked.connect(self.openNewCatPop)
    self.editCategory.clicked.connect(self.openEditCatPop)
    self.deleteCategory.clicked.connect(self.deleteSelectedCategory)
    self.undoBtn.clicked.connect(self.uncategorizeCompletedTransaction)
    # self.showCategorySummary()

    # Planning Tab
    self.recurrenceComboBox.hide()
    self.recurringBtn.toggled.connect(self.recurrenceComboBox.show)
    self.singularBtn.toggled.connect(self.recurrenceComboBox.hide)
    self.createPlannedTransactionsWidget()
    self.savePlannedT.clicked.connect(self.savePlannedTransaction)
    self.updateCategoryBox()
    self.removeBtn.clicked.connect(self.removePlannedTransaction)

    # Analysis Tab
    self.plotWindow.clicked.connect(self.openPlottingWindow)

    # Projection Tab
    self.cashProjectionsBtn.clicked.connect(self.openProjectionWindow)


    '''
    Setup Tab Functions - uses basic information mainly for predictive analysis.
    Put it all in one tab to consolidate arbitrary user input.

    '''


  def saveStartInfo(self):
    checkingAccBal = 0
    incomeAmt = 0
    payDayFreq = None
    payDay = None
    payCreditDate = None

    invalidEntries = 0
    # Validating proper checking acc input
    try:
      checkingAccBalance = int(self.checkingAccBal.text())
    except ValueError:
      invalidEntries += 1
      self.checkingAccBal.setText("")
      self.checkingAccBal.setPlaceholderText("Enter an integer or float value")

    # Validating proper income amt input
    try:
      incomeAmt = int(self.incomeAmount.text())
      
    except ValueError:
      invalidEntries += 1
      self.incomeAmount.setText("")
      self.incomeAmount.setPlaceholderText("Enter an integer or float value")
    
    # ComboBox wont allow for bad input
    payDayFreq = self.freqPayDay.currentText()

    # Validating proper date format for nextPayDay
    # This isnt perfect but if its this close to format
    # I will assume the user properly entered a date
    # Can be refined to make sure dates are valid
    try:
      payDay = to_datetime(self.nextPayDay.text())
       
    except:
      invalidEntries += 1
      self.nextPayDay.setText("")
      self.nextPayDay.setPlaceholderText("Use format mm/dd/yyyy")

    # See block above
    try:
      payCreditDate = to_datetime(self.nextCCPayment.text())
        
    except:
      invalidEntries += 1
      self.nextCCPayment.setText("")
      self.nextCCPayment.setPlaceholderText("Use format mm/dd/yyyy")

    self.app.saveUserSetupData(checkingAccBalance, incomeAmt, payDayFreq,
                               payDay, payCreditDate)
    if invalidEntries == 0:
      self.fileOpen()
      
  '''

  Analysis Table Funcs - handles all functions that deal with the analysis tab and analysis
  QTableWidget; pulls data from API and updates concurrently with categorization method calls.
  
  '''
  def openProjectionWindow(self):
    self.projectionWidget = ProjectionWidget(self.app) 
    self.projectionWidget.show()


  def createAnalysisTable(self):
    self.categoryAnalysisTable.setRowCount(0)
    categories = self.app.getCategoryNamesList()
    for c in categories:
      if c != "Unhandled":
        row = self.categoryAnalysisTable.rowCount()
        self.categoryAnalysisTable.insertRow(row)
        self.categoryAnalysisTable.setItem(row, 0, QtWidgets.QTableWidgetItem(c))
        self.categoryAnalysisTable.setItem(row, 1, QtWidgets.QTableWidgetItem(str(self.app.getAmountAllottedByCategory(c))))
        self.categoryAnalysisTable.setItem(row, 2, QtWidgets.QTableWidgetItem(str(self.app.getAmountSpentByCategory(c))))
        self.categoryAnalysisTable.setItem(row, 3, QtWidgets.QTableWidgetItem(str(self.app.getAmountPlannedByCategory(c))))
        self.categoryAnalysisTable.setItem(row, 4, QtWidgets.QTableWidgetItem(str(self.app.getDeltaByCategory(c))))
        if row != 0:
          self.flagCategory(c)
        self.updateSpendingLabels()

    header = self.categoryAnalysisTable.horizontalHeader()
    header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
    header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
    header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)
    header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)


  def addNewRowToAnalysis(self, c):
    row = self.categoryAnalysisTable.rowCount()
    self.categoryAnalysisTable.setItem(row, 0, QtWidgets.QTableWidgetItem(c))
    self.categoryAnalysisTable.setItem(row, 1, QtWidgets.QTableWidgetItem(str(self.app.getAmountAllottedByCategory(c))))
    self.categoryAnalysisTable.setItem(row, 2, QtWidgets.QTableWidgetItem(str(self.app.getAmountSpentByCategory(c))))
    self.categoryAnalysisTable.setItem(row, 3, QtWidgets.QTableWidgetItem(str(self.app.getAmountPlannedByCategory(c))))
    self.categoryAnalysisTable.setItem(row, 4, QtWidgets.QTableWidgetItem(str(self.app.getDeltaByCategory(c))))
    self.flagCategory(row)



  def updateAnalysisTable(self, category):
    row = self.app.getCategoryNamesList().index(category) - 1
    self.categoryAnalysisTable.setItem(row, 0, QtWidgets.QTableWidgetItem(category))
    self.categoryAnalysisTable.setItem(row, 1, QtWidgets.QTableWidgetItem(str(self.app.getAmountAllottedByCategory(category))))
    self.categoryAnalysisTable.setItem(row, 2, QtWidgets.QTableWidgetItem(str(self.app.getAmountSpentByCategory(category))))
    self.categoryAnalysisTable.setItem(row, 3, QtWidgets.QTableWidgetItem(str(self.app.getAmountPlannedByCategory(category))))
    self.categoryAnalysisTable.setItem(row, 4, QtWidgets.QTableWidgetItem(str(self.app.getDeltaByCategory(category))))
    self.flagCategory(category)
    self.updateSpendingLabels()


  def fillAnalysisTable(self):
    categories = self.app.getCategoryNamesList()
    for c in categories:
      if c != "Unhandled": 

        row = self.categoryAnalysisTable.rowCount()
        self.categoryAnalysisTable.insertRow(row)

        self.categoryAnalysisTable.setItem(row, 0, QtWidgets.QTableWidgetItem(c))
        self.categoryAnalysisTable.setItem(row, 1, QtWidgets.QTableWidgetItem(str(self.app.getAmountAllottedByCategory(c))))
        self.categoryAnalysisTable.setItem(row, 2, QtWidgets.QTableWidgetItem(str(self.app.getAmountSpentByCategory(c))))
        self.categoryAnalysisTable.setItem(row, 3, QtWidgets.QTableWidgetItem(str(self.app.getAmountPlannedByCategory(c))))
        self.categoryAnalysisTable.setItem(row, 4, QtWidgets.QTableWidgetItem(str(self.app.getDeltaByCategory(c))))

    # resizing
    header = self.categoryAnalysisTable.horizontalHeader()
    header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)    
    header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
    header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)
    header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)


  def flagCategory(self, category):
  
    row = self.app.getCategoryNamesList().index(category) - 1

    '''
    Turns QTableWidgetItem yellow to alert user that the sum their planned transactions 
    and completed Transactions for a given category exceed the allotted amount
    '''
    if self.app.getAmountAllottedByCategory(category) < self.app.getAmountSpentByCategory(category) + self.app.getAmountPlannedByCategory(category):
      self.categoryAnalysisTable.item(row, 0).setBackground(QtGui.QColor(240, 240, 5))

    '''
    Turns QTableWidgetItem red to alert user that the sum their 
    completed Transactions for a given category exceed the allotted amount
    '''
    if self.app.getAmountAllottedByCategory(category) < self.app.getAmountSpentByCategory(category):
      self.categoryAnalysisTable.item(row, 0).setBackground(QtGui.QColor(240, 5, 5))


  def createPlannedTransactionsWidget(self):
    self.tabWidget.clear()
    for category in self.app.getCategoryNamesList():
      if category != "Unhandled":
        tab = QTableWidget()
        self.tabWidget.addTab(tab, category)
        self.tabWidget.setCurrentWidget(tab)
        for i in range(3):
          self.tabWidget.currentWidget().insertColumn(i)
        self.fillTransactionWidget(category)


  def removePlannedTransaction(self):
    row = self.tabWidget.currentWidget().currentRow()
    index = self.tabWidget.currentIndex()
    category = self.app.getCategoryNamesList()[index + 1]
    name = self.tabWidget.currentWidget().item(row, 1).text()
    self.app.removePlannedTransaction(category, name)
    self.tabWidget.currentWidget().removeRow(row)
    self.app.saveData()


  def savePlannedTransaction(self):
    transaction = TransactionData()
    transaction.name = self.namePlannedT.text()
    transaction.category = self.categoryComboBox.currentText()
    # Validate amount by user input
    try:
      transaction.amount = float(self.amountPlannedT.text())
    except ValueError:
      invalidEntries += 1
      self.amountPlannedT.setText("")
      self.amountPlannedT.setPlaceholderText("Enter a float or an integer")

    if self.recurringBtn.isChecked():
      transaction.recurring = True
      transaction.rateOfRecurrence = self.getToggledFrequency()[1]
    else:
      transaction.recurring = False
        
    transaction.date = self.calendarWidget.selectedDate().toString("yyyy-MM-dd")
    if self.checkingRadioBtn.isChecked():
      transaction.paymentMethod = 'Checking'
      transaction.paymentMethod
    else:
      transaction.paymentMethod = 'Credit'

    if invalidEntries == 0:

      self.app.createPlannedTransaction(transaction)
      self.createPlannedTransactionsWidget()
      self.app.saveData()


  def getToggledFrequency(self):
    if self.recurringBtn.isChecked():
      return True, self.recurrenceComboBox.currentText()
    return False


  def updateCategoryBox(self):
    self.categoryComboBox.clear()
    categoryNamesList = self.app.getCategoryNamesList()
    for c in categoryNamesList:
      if c != "Unhandled":
        self.categoryComboBox.addItem(c)


  def updateSpendingLabels(self):
    categories = self.app.getCategoryNamesList()
    totalSpent = 0
    totalAllotted = 0
    for c in categories:
      if c != "Unhandled":
        totalSpent += self.app.getAmountSpentByCategory(c)
        totalAllotted += self.app.getAmountAllottedByCategory(c)
    pctSpent = round(totalSpent / totalAllotted, 1) * 100
    self.amountSpentLabel.setText("$" + str(round(totalSpent, 2)))
    self.percentageSpentLabel.setText(str(pctSpent) + "%")

    if pctSpent <= 65:
      self.percentageSpentLabel.setStyleSheet("color: green;")
    elif 65 < pctSpent < 90:
      self.percentageSpentLabel.setStyleSheet("color: rgb(255, 200, 0);")
    else:
      self.percentageSpentLabel.setStyleSheet("color: red;")


 
  '''

  Categorize Transactions Funcs - uses the DragAndDropTableWidget Object to categorize 
  transaction objects into user-defined categories which are then used for analysis
 
  '''


  def uncategorizeCompletedTransaction(self):
    row = self.categoryWidget.currentWidget().currentRow()

    if type(self.categoryWidget.currentWidget().item(row, 0)) == QTableWidgetItem:
      date = self.categoryWidget.currentWidget().item(row, 1).text()
      referenceNumber = int(self.categoryWidget.currentWidget().item(row, 0).text())
      location = self.categoryWidget.currentWidget().item(row, 2).text()
      amount = self.categoryWidget.currentWidget().item(row, 3).text()
      c = self.app.getCategoryNamesList()[self.categoryWidget.currentIndex() + 1]
      self.app.unregisterCompletedTransaction(c, referenceNumber)
      self.app.registerCompletedTransaction("Unhandled", referenceNumber)
      self.app.diagnosticDbg()
      self.app.saveData()
      self.returnTransactionToUnhandled(referenceNumber, date, location, amount)
      self.categoryWidget.currentWidget().removeRow(row)
      self.updateCategorySummary(c)


  def returnTransactionToUnhandled(self, referenceNumber, date, location, amount):
    row = self.tableWidget.rowCount()
    self.tableWidget.insertRow(row)
    self.tableWidget.setItem(row, 0, QtWidgets.QTableWidgetItem(str(referenceNumber)))
    self.tableWidget.setItem(row, 1, QtWidgets.QTableWidgetItem(date))
    self.tableWidget.setItem(row, 2, QtWidgets.QTableWidgetItem(location))
    self.tableWidget.setItem(row, 3, QtWidgets.QTableWidgetItem(amount))


  def fillTransactionWidget(self, category):
    plannedTransactions = self.app.getPlannedTransactions(category)
    if plannedTransactions != None:
      for t in plannedTransactions:
        rowPos = self.tabWidget.currentWidget().rowCount()          
        self.tabWidget.currentWidget().insertRow(rowPos)
        self.tabWidget.currentWidget().setItem(rowPos, 0, QtWidgets.QTableWidgetItem(str(t.date)))
        self.tabWidget.currentWidget().setItem(rowPos, 1, QtWidgets.QTableWidgetItem(t.name))
        self.tabWidget.currentWidget().setItem(rowPos, 2, QtWidgets.QTableWidgetItem(str(t.amount)))

      header = self.tabWidget.currentWidget().horizontalHeader()
      header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)    
      header.setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
      header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)


  def getToggledFrequency(self):
    if self.recurringBtn.isChecked():
      return True, self.recurrenceComboBox.currentText()
    return False


  def createPlannedTransactionsWidget(self):
    self.tabWidget.clear()
    for category in self.app.getCategoryNamesList():
      if category != "Unhandled":
        tab = QTableWidget()
        self.tabWidget.addTab(tab, category)
        self.tabWidget.setCurrentWidget(tab)
        for i in range(3):
          self.tabWidget.currentWidget().insertColumn(i)
        self.fillTransactionWidget(category)



  def openNewCatPop(self):
    '''
    when newCategory button is pushed on categorize tab, this will
    prompt a popup that allows user to enter a new category, monthly allotment
    and a list of potential keywords
    '''
    self.Dialog = QtWidgets.QDialog()
    self.ui = Ui_createDialog()
    self.ui.setupUi(self.Dialog, self.app)
    self.ui.saveCategoryInfo.clicked.connect(self.updateCategoryWidget)
    self.Dialog.show()


  def openEditCatPop(self):
    '''
    Opens same window as openNewCatPop but autofills the 
    information and allows it to be edited
    '''

    self.tab = self.categoryWidget.currentIndex()        
    self.index = self.app.getCategoryNamesList()[self.tab+1]
    self.Dialog = QtWidgets.QDialog()
    self.editUi = Ui_editDialog()
    self.editUi.setupUi(self.Dialog, self.app)
    self.Dialog.show()

    self.editUi.newCategoryName.setText(self.index)
    self.editUi.newCategoryAllotment.setText(str(self.app.getAmountAllottedByCategory(self.index)))

    # First, check if there are any keywords to be added.
    # Add items only if an iterable list of keywords is returned.
    keywords = self.app.getKeywordsByCategory(self.index)
    if keywords != None:
      self.editUi.newCategoryKeywords.addItems(keywords)


  def updateCategoryWidget(self):
    self.app.saveData()
    self.createCategoryWidget()
    self.createPlannedTransactionsWidget()
    self.updateCategoryBox()
    self.createAnalysisTable()


  def createCategoryWidget(self):
    self.categoryWidget.clear()
    for category in self.app.getCategoryNamesList():
      if category != "Unhandled":
        tab = DragDropTableWidget(self.app, self)
        tab.setAcceptDrops(True)
        self.categoryWidget.addTab(tab, category)
        self.categoryWidget.setCurrentWidget(tab)
        for i in range(4):
          self.categoryWidget.currentWidget().insertColumn(i)

        self.fillCategoryWidget(category)

        header = self.categoryWidget.currentWidget().horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)    
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)


  def moveRowToDropDestination(self, referenceNumber, date, location, amount, category):
    rowPos = self.categoryWidget.currentWidget().rowCount()
    self.categoryWidget.currentWidget().insertRow(rowPos)
    self.categoryWidget.currentWidget().setItem(rowPos, 0, QtWidgets.QTableWidgetItem(str(referenceNumber)))
    self.categoryWidget.currentWidget().setItem(rowPos, 1, QtWidgets.QTableWidgetItem(date))
    self.categoryWidget.currentWidget().setItem(rowPos, 2, QtWidgets.QTableWidgetItem(location))
    self.categoryWidget.currentWidget().setItem(rowPos, 3, QtWidgets.QTableWidgetItem(amount))
    self.updateCategorySummary(category)


  def showCategorySummary(self):
    index = self.categoryWidget.currentIndex()
    category = self.app.getCategoryNamesList()[index + 1]
    self.categorySpent.setText(str(self.app.getAmountSpentByCategory(category)))
    self.categoryAllotted.setText(str(self.app.getAmountAllottedByCategory(category)))


  def updateCategorySummary(self, category):
    self.categoryAllotted.setText(str(self.app.getAmountAllottedByCategory(category)))
    self.categorySpent.setText(str(self.app.getAmountSpentByCategory(category)))

      
  def fillCategoryWidget(self, category):
    for t in self.app.getCompletedTransactionsByCategory(category).values():
      rowPos = self.categoryWidget.currentWidget().rowCount()
      self.categoryWidget.currentWidget().insertRow(rowPos)
      self.categoryWidget.currentWidget().setItem(rowPos, 0, QtWidgets.QTableWidgetItem(str(t.referenceNumber)))
      self.categoryWidget.currentWidget().setItem(rowPos, 1, QtWidgets.QTableWidgetItem(t.date))
      self.categoryWidget.currentWidget().setItem(rowPos, 2, QtWidgets.QTableWidgetItem(t.location))
      self.categoryWidget.currentWidget().setItem(rowPos, 3, QtWidgets.QTableWidgetItem(t.amount))


  def printUnhandledTransactions(self):
    for t in self.app.getUnhandledTransactions().values():
      rowPos = self.tableWidget.rowCount()
      self.tableWidget.insertRow(rowPos)
      self.tableWidget.setItem(rowPos, 0, QtWidgets.QTableWidgetItem(str(t.referenceNumber)))
      self.tableWidget.setItem(rowPos, 1, QtWidgets.QTableWidgetItem(t.date))
      self.tableWidget.setItem(rowPos, 2, QtWidgets.QTableWidgetItem(t.location))
      self.tableWidget.setItem(rowPos, 3, QtWidgets.QTableWidgetItem(t.amount))
      # resizing the columns
      header = self.tableWidget.horizontalHeader()       
      header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
      header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
      header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
      header.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)


  def deleteSelectedCategory(self):
    self.tab = self.categoryWidget.currentIndex() + 1        
    self.index = self.app.getCategoryNamesList()[self.tab]
    self.app.deleteCategory(self.index)
    self.updateCategoryWidget()
    self.createAnalysisTable()
    

 
  '''

  Open Dialog Window Funcs - Opens all popup windows for analytics and user input
  
  '''

  def openPlottingWindow(self):
    plotWindow = PlottingWindow(self.app)
    plotWindow.show()


  def openEditCatPop(self):

    '''
    Opens same window as openNewCatPop but autofills the 
    information and allows it to be edited
    '''

    self.tab = self.categoryWidget.currentIndex()        
    self.index = self.app.getCategoryNamesList()[self.tab+1]
    self.Dialog = QtWidgets.QDialog()
    self.editUi = Ui_editDialog()
    self.editUi.setupUi(self.Dialog, self.app)
    self.Dialog.show()

    self.editUi.newCategoryName.setText(self.index)
    self.editUi.newCategoryAllotment.setText(str(self.app.getAmountAllottedByCategory(self.index)))

    # First, check if there are any keywords to be added.
    # Add items only if an iterable list of keywords is returned.
    keywords = self.app.getKeywordsByCategory(self.index)
    if keywords != None:
      self.editUi.newCategoryKeywords.addItems(keywords)


  def openNewCatPop(self):
    '''
    when newCategory button is pushed on categorize tab, this will
    prompt a popup that allows user to enter a new category, monthly allotment
    and a list of potential keywords
    '''
    self.Dialog = QtWidgets.QDialog()
    self.ui = Ui_createDialog()
    self.ui.setupUi(self.Dialog, self.app)
    self.ui.saveCategoryInfo.clicked.connect(self.updateCategoryWidget)
    self.Dialog.show()


  '''

  Other Funcs - Miscellaneous Supporting Funcs

  '''


  def fileOpen(self):
    filePath, _ = QtWidgets.QFileDialog.getOpenFileName()
    self.app.sortCompletedTransactions(filePath)
    self.printUnhandledTransactions()
    self.createCategoryWidget()
    self.createAnalysisTable()


      



      

##############################################################################################
                  # beginning of auto-generated code
##############################################################################################
